
<html>
  <head>
    <title>Leap movement tests</title>
    <style>
      canvas { background-color: black; position: fixed; left: 0px; top: 0px; }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/leap.min.js"></script>
    <script src="js/OBJLoader.js"></script>
	<script>
// adapted from Soledad Penadés
function buildAxes( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( length, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, length, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, length ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, false ) ); // +Z

	var num = 40; //number of minor axis lines DIVIDE BY 2 and 4

	length = 1/3*length
	for ( var i=0; i<num + 1; i++ ){
		axes.add( buildAxis( new THREE.Vector3( length, 0, num/4*(i-num/2)), new THREE.Vector3(-length, 0, num/4*(i-num/2)), 0xFFFFFF, false) );
		axes.add( buildAxis( new THREE.Vector3(num/4*(i-num/2),0, length), new THREE.Vector3(num/4*(i-num/2),0 , -length), 0xFFFFFF, false) );
	}

        return axes;

}

function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat; 

        if(dashed) {
                //mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                //mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }
	mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LinePieces );

        return axis;

}


	var init = function(){
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.10, 1000);
	camera.position.set(0,200,400);
	
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      cube = new THREE.Mesh( new THREE.CubeGeometry( 400, 2, 200 ), new THREE.MeshNormalMaterial() );
      //scene.add(cube);
	scene.add(buildAxes(600));
	camera.lookAt(new THREE.Vector3(0,0,0));

		// Create a light, set its position, and add it to the scene.
		var light = new THREE.AmbientLight( 0x400010 ); // soft white light 
		scene.add( light );
		var light = new THREE.PointLight(0xffffff);
		light.position.set(-100,200,100);
		scene.add(light);



				var manager = new THREE.LoadingManager();

				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};
		


				// model
				var objMaterial = new THREE.MeshLambertMaterial( { color: 0xFF0000 });
				// var object = new THREE.Mesh(new THREE.CylinderGeometry(50, 50, 200, 50, 50, false), objMaterial);
				// scene.add(object);

				var loader = new THREE.OBJLoader( manager );
				loader.load( 'obj/male02.obj', function ( object ) {

					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.material = objMaterial;

						}

					} );

					object.position.set(0,-80,0);
					scene.add( object );

				} );
	var counter = 0;
	var prevroll = -999;

      Leap.loop(function(frame) {
	if (prevroll == -999 && frame.hands.length > 0){
		prevroll = frame.hands[0].roll();
		console.log(prevroll);
	}

	//console.log(camera.position.z);
	
	if (frame.hands.length == 1){
		var hand = frame.hands[0];
			//counter += .01;
	if (hand.grabStrength < .2){
		counter += (hand.roll() - prevroll)/10;
		camera.position.x = -Math.sin(counter)*400;
		camera.position.z = Math.cos(counter)*400;
		camera.lookAt(new THREE.Vector3(0,0,0));
		
	/*
		var x = hand.palmPosition[0];
		var y = hand.palmPosition[1];
		var z = hand.palmPosition[2];
		//cube.position.x = x;
		//cube.position.y = y-200;
		//if (hand.pitch > 0){
		//	cube.rotation.x  -= 1;
		//}
		//cube.rotation.x = hand.pitch();
		//cube.rotation.z = hand.roll();
	*/

	}}
	
	//cube.rotation.x += .01

	//if(frame.gestures.length > 0) console.log(frame.gestures);

        renderer.render(scene, camera);
      });
	};
    </script>
  </head>
  <body onload="setTimeout(init, 100);">
    <div id="out"></div>
  </body>
</html>
