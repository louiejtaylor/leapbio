
<html>
  <head>
    <title>Leap movement tests</title>
    <style>
      canvas { background-color: black; position: fixed; left: 0px; top: 0px; }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/leap.min.js"></script>
    <script src="js/OBJLoader.js"></script>
	<script>
// adapted from Soledad Penadés
function buildAxes( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

        return axes;

}

function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat; 

        if(dashed) {
                //mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                //mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }
	mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LinePieces );

        return axis;

}


	var init = function(){
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.10, 1000);
	camera.position.set(40,10,10);
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      camera.position.z = 400;
      cube = new THREE.Mesh( new THREE.CubeGeometry( 400, 2, 200 ), new THREE.MeshNormalMaterial() );
      scene.add(cube);
	scene.add(buildAxes(1000));

		// Create a light, set its position, and add it to the scene.
		var light = new THREE.PointLight(0xffffff);
		light.position.set(-100,200,100);
		scene.add(light);



				var manager = new THREE.LoadingManager();

				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};
		


				// model
				var objMaterial = new THREE.MeshLambertMaterial( { color: 0xFF0000 });
				// var object = new THREE.Mesh(new THREE.CylinderGeometry(50, 50, 200, 50, 50, false), objMaterial);
				// scene.add(object);

				var loader = new THREE.OBJLoader( manager );
				loader.load( 'obj/male02.obj', function ( object ) {

					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.material = objMaterial;

						}

					} );

					object.position.y = - 80;
					scene.add( object );

				} );


      Leap.loop(function(frame) {
	var hand = frame.hands[0];
	if (frame.hands.length == 1){
	if (hand.grabStrength < .2){
		var x = hand.palmPosition[0];
		var y = hand.palmPosition[1];
		var z = hand.palmPosition[2];
		cube.position.x = x;
		cube.position.y = y-200;
		//if (hand.pitch > 0){
		//	cube.rotation.x  -= 1;
		//}
		cube.rotation.x = hand.pitch();
		cube.rotation.z = hand.roll();

	}}
	
	//cube.rotation.x += .01

	//if(frame.gestures.length > 0) console.log(frame.gestures);

        renderer.render(scene, camera);
      });
	};
    </script>
  </head>
  <body onload="setTimeout(init, 100);">
    <div id="out"></div>
  </body>
</html>
